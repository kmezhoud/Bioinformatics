# Analyse des Interactions de protéines

1.  Orale presentation

2.  Include slides

    -   second level

        -   third level

## Cas d'étude: Identification Graphique de sous-réseaux de gènes associés aux cancers basé sur des données protéomiques réduites {.short-title="Cas d'étude"}

This tutorial describes the main steps used to construct an enriched network from a list of genes with their expression values. The network includes the fold change, the False discovery rate (FDR), the gene expression correlation, the most often involved biological processes, and the most likely corresponding diseases. All the main steps are illustrated by screen shots. The [Tools & Data](#tools-data) section lists all the tools and data required. The "Data computing" section shows you how to compute the data. The Experimental procedure section lists briefly all the steps, and the Walk-through example section illustrates these steps. The final section lists all the software and packages that were tested during this study, but not selected for inclusion in this Note.

### Tools & Data {#tools-data}

For this tutorial you will need:

1.  Bioinformatic tools

Cytoscape [@Shannon2003; @Cline2007] software implemented by Reactome FIs [@Wu2010], Advanced Network merge, NetworkAnalyzer, and ClueGO [@Bindea2009] Apps.

2.  Experimental Data

To find out more about the file format, download the corresponding supplemental file indicated in parentheses.

-   The list of modulated protein saved in one column in text file (only_modulated_symbol.txt). Convert the protein ID on gene symbol (HGNC or HUGO symbol) using ID Mapping service, such as:

    -   [BioMart](https://www.ensembl.org/info/data/biomart/index.html)
    -   [Uniprot](http://www.uniprot.org/)
    -   [Idconverter](https://cran.r-project.org/web/packages/IDConverter/index.html) [@Alibes2007]
    -   [GAGE](https://bioconductor.org/packages/release/bioc/html/gage.html) [@Luo2009] with the `eg2sym` function.

-   The protein expression values. The following example of gene expression is divided into two groups and 3 replicates. (proteinEXP.txt)

-   Node Attributes

    -   Fold change of the protein identified (Fold_Change.NA)
    -   False discovery rate of the z score or some other statistical test (FDR.NA)
    -   Correlated protein expression by statistical analysis (Correlation_Network.sif)
    -   Cancer-protein network (Cancer_Network.sif)

-   Edge attributes

    -   The correlation rate of Protein expression (Correlation+Cancer.EA)
    -   The gene expression profile overlap between our experiments and clinical data from the [cBio Cancer Genomics Portal]((http://www.cbioportal.org/)) [@Cerami2012, @Gao2013] (Correlation+Cancer.EA)

### Data Computing

#### Gene list

We assume that the protein list with quantitative analysis has already been compiled . Supplemental **proteinEXP.txt** file gives an example of the quantitative data which will be used.

Pre-process the expression data into a format suitable for network analysis, clean the data by removing obvious outlier samples or excessive numbers of missing entries, and then load the data. The gene list is selected after statistical analysis. The Fold change and False discovery rate are then computed and saved in the corresponding files: **Fold_Change.NA** and **FDR.NA**.

#### Multiple Correlation analysis of protein expression

Two genes are said to be connected by an edge if their expression values are closely correlated (statistical significance). We used [CORREP](https://www.bioconductor.org/packages/release/bioc/html/CORREP.html) package [@Zhu2007] to estimate the gene expression correlation.

This program assumes that data are arranged with the variables (genes) in rows and conditions (persons) in columns . It is strongly suggested that factor names be included in the data file, as this information is used in the results output.

We specified that the proteins (or genes) are the variables, and the people correspond to the different conditions. In our case we have 235 variables, 6 conditions, and one replicate. It is not possible to carry out multiple correlation analysis using only two conditions and 3 replicates (like in our experimental design).

Following R codes makes it possible to compute and extract correlated gene expression levels upper that threshold.

```{r eval=FALSE}
# Install CORREP package from Bioconductor

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("CORREP")


```

Load needed package

```{r message=FALSE, warning=FALSE}
library(dplyr)
```


```{r}
# read expression data
proteinEXP <- read.table(file = "data/cytoscape_input/proteinEXP.txt", header = TRUE, row.names = 1)

head(proteinEXP)
```

```{r}
# standardization / Scale matrix
#  Apply by rows (1), the function x/sd(x)
proteinEXP.std <- apply(X = proteinEXP, MARGIN = 1, FUN = function(x) x/sd(x)) |>
                  t()  # transpose the matrix
  
proteinEXP.std |>
head(4) # return the first 4 rows
```

```{r}
## run correlation for matrix x with 1 replicate and 235 genes
cor.proteinEXP.std <- CORREP::cor.balance(x = proteinEXP.std, m=1, G=235)

genes <- rownames(proteinEXP)
colnames(cor.proteinEXP.std) <- genes
rownames(cor.proteinEXP.std) <- genes

#class(cor.proteinEXP.std)
#dim(cor.proteinEXP.std)
cor.proteinEXP.std[1:5, 1:5]
```

```{r}
# find indexes of all correlated genes upper/equal than 0.81 and under 1
idx <- which(abs(cor.proteinEXP.std) >=0.811 & abs(cor.proteinEXP.std) < 1 ,arr.ind=TRUE)

head(idx)
```

```{r}
# get correlated genes with rate value
cor.proteinEXP.std.filter <- data.frame(gene1 = genes[idx[,1]], 
                                        gene2= genes[idx[,2]], 
                                        value= cor.proteinEXP.std[idx])

#dim(cor.proteinEXP.std.filter)
head(cor.proteinEXP.std.filter)
```

From *cor.proteinEXP.std.filter* object we can generate correlated gene network. Cytoscape accepts files with with *.sif* extention as following `gene1[space]PP[space]gene2`. 

```{r}
correlation_network <- paste0(cor.proteinEXP.std.filter$gene1, " PP ", cor.proteinEXP.std.filter$gene2)

write.table(correlation_network, file = "data/cytoscape_input/new_version/Correlation_Network.sif",
            row.names = FALSE, quote = FALSE, col.names="")

head(correlation_network)
```


The format of edge attributes that will be imported by Cytoscape must has this format `gene1+%28pp%29+gene2=correlation value`.

In our case, we need to concatenate the three columns and add `+%28pp%29+` between genes and `=` before value.

```{r}
# paste columns
correlated_genes.EA <- paste0(cor.proteinEXP.std.filter$gene1, "+%28pp%29+", 
                    cor.proteinEXP.std.filter$gene2, "=",
                    cor.proteinEXP.std.filter$value)

length(correlated_genes.EA)
head(correlated_genes.EA)
```



The `correlated_genes.EA` object is the Egdes Attribution of correlated genes. It  will be saved and used as input file for cytoscape. 

But before to save it, we need to add Edges attribution of interaction between genes and cancers.

We will use [cBio Portal](https://www.cbioportal.org/) web service to predict the frequency of altered genes (only_modulated_symbol.txt file) in existing cancers studies.


#### Query [cBio Portal](https://www.cbioportal.org/) 

##### Cancer Type Frequencies {#cancer-type-frequency}

We have 27 genes and the cBioPortal accepts queries with limited genes number **14**. We subset the genes list to 2 groups and merge the outputs together.

The gene list was submitted  with the **curated set of non redundant studies** option. This first request told us how much the genes were modulated in selected cancer types. All cancers type were then ranked in decreasing order of the overlap of their gene expression profiles. The table will saved as *Cancer-frequency.NA*.

![](img/query_genes_list.png)
After quering, go to the **Cancer Type Summary** Tab and visualize the results.  Download the data and save it as *cancer_type_summary_1.txt*. Repeat the same [process](#cancer-type-frequency) for the remains 13 genes and save it as *cancer_type_summary_2.txt*.


![](img/cBio_Cancer_Type_Sum_1.png)


```{r}
cancer_type_summary_1 <- read.table(file = "data/cBioPortal_output/cancer_types_summary_1.txt", header = TRUE, sep = "\t")
cancer_type_summary_2 <- read.table(file = "data/cBioPortal_output/cancer_types_summary_2.txt", header = TRUE, sep = "\t")
head(cancer_type_summary_1)
```

**Alteration.Frequency** variable is computed for each query of all input genes list. In our case we have to compute the `mean/median` of **Alteraction.Frequency** of the two queries.


 
```{r}

cancer_type_summary_1_freq <- cancer_type_summary_1 |>
                              group_by(Cancer.Type) |>
                              mutate(Count = sum(Alteration.Count),
                                     Freq = sum(Alteration.Frequency)) |>
                              #select(Cancer.Type, Alteration.Frequency, Freq) |>
                              distinct(Cancer.Type, Freq, .keep_all = FALSE) |>
                              arrange(desc(Freq)) |>
                              mutate(Freq = round(Freq/100, digits = 2))

 cancer_type_summary_2_freq <- cancer_type_summary_2 |>
                              group_by(Cancer.Type) |>
                              mutate(Count = sum(Alteration.Count),
                                     Freq = sum(Alteration.Frequency)) |>
                              #select(Cancer.Type, Alteration.Frequency, Freq) |>
                              distinct(Cancer.Type, Freq, .keep_all = FALSE) |>
                              arrange(desc(Freq)) |>
                              mutate(Freq = round(Freq/100, digits = 2)) 


head(cancer_type_summary_1_freq)
```


```{r}
# bind the two summaries and compute the mean
cancer_type_summary_freq <- cancer_type_summary_1_freq |>
                        bind_rows(cancer_type_summary_2_freq) |>
                        group_by(Cancer.Type) |>
                        mutate(Freq_mean= mean(Freq)) |>
                        arrange(Cancer.Type) |>
                        distinct(Cancer.Type, Freq_mean) |>
                        arrange(desc(Freq_mean))



head(cancer_type_summary_freq,n = 6)

```


```{r}

cancer_frequency <- paste0(cancer_type_summary_freq$Cancer.Type, 
                           " = ", cancer_type_summary_freq$Freq_mean)
  
## save only the first 6 cancers
  
write.table(head(cancer_frequency, 10),
            file = "data/cytoscape_input/new_version/Cancer_frequency.NA",
            row.names = FALSE, quote = FALSE, col.names = "Cancer frequency (class=java.lang.Double)"
            ) 

head(cancer_frequency)
```

##### Gene Alteration Frequency by Cancer Type {#gene-alteration-frequency-by-cancer-type}

In the second step, the search was refined by specifying the cancers (one by one), which involved a wider range of gene lists.

We will focus on the first 5 cancer type listed by *cancer_type_summary_freq* object.

We used only the “mRNA Expression Z-Scores vs Normals” option. We specified the direction of the modulation using Advanced: Onco Query Language (OQL). 

For example, with PZP: EXP > 1, the search selects only cancer cases that display up-regulation of PZP. Based on the *Fold_Change.NA* file, we used OQL as explained in supplemental *only-modulatedEXP.txt*.

We started by Lung Cancer which has the higher  frequency. 

We have to search manually which Lung cancer study has mRNa expression data. Select studies with biggest samples essais.

There is no way to filter studies by **genomic profile**.  check boxes **one by one** and see if mRNA expression option appears.

In this case we can query more gene list (27).

![](img/Lung_EXP_query.png)



![](img/gene_alteration_frequency_by_cancer.png)    
Save the file as **gene_alteration_frequency_Lung.tsv**. 


```{r}
gene_alteration_frequency_Lung <- read.table("data/cBioPortal_output/gene_alteration_frequency_Lung.tsv",
                                             header = TRUE, sep = "\t")

head(gene_alteration_frequency_Lung)
```
The next step is to attribute gene alteration frequency to gene-cancer Edges. 

Based on  *gene_alteration_frequency_Lung* object we need to build a list like `gene1+%28pp%29+cancer1=gene_alteration_rate` and joint it to `correlated_genes.EA`


```{r}
gene_cancer_freq_Lung <- paste0(gene_alteration_frequency_Lung$Gene.Symbol, 
                          "+%28pp%29+", "Lung_C=",  
                          as.numeric(sub("%","", 
                                         gene_alteration_frequency_Lung$Percent.Samples.Altered))/100
                          )
head(gene_cancer_freq_Lung)
```

**Do the same [steps](#gene-alteration-frequency-by-cancer-type) for the 5 others Cancer Type: Ovarian Cancer, Invasive Breast, Uterine Endometrioid Carcinoma, Skin Cancer Non-Melanoma, Bladder/Urinary Tract Cancer** 


```{r}
gene_alteration_frequency_Breast <- read.table("data/cBioPortal_output/gene_alteration_frequency_Breast.tsv",
                                             header = TRUE, sep = "\t")

gene_alteration_frequency_Bladder <- read.table("data/cBioPortal_output/gene_alteration_frequency_Bladder.tsv",
                                             header = TRUE, sep = "\t")


gene_alteration_frequency_Skin <- read.table("data/cBioPortal_output/gene_alteration_frequency_Skin.tsv",
                                             header = TRUE, sep = "\t")

gene_alteration_frequency_Uterine <- read.table("data/cBioPortal_output/gene_alteration_frequency_Uterine.tsv",
                                             header = TRUE, sep = "\t")

 gene_alteration_frequency_5_cancers <- bind_rows(cbind(gene_alteration_frequency_Lung, Cancer = "Lung"),
                                                  cbind(gene_alteration_frequency_Breast, Cancer="Breast"),
                                                  cbind(gene_alteration_frequency_Bladder, Cancer="Bladder"),
                                                  cbind(gene_alteration_frequency_Skin, Cancer="Skin"),
                                                  cbind(gene_alteration_frequency_Uterine, Cancer = "Uterine")
                                                  )
 
 
 gene_cancer_freq_5_cancers <- paste0(gene_alteration_frequency_5_cancers$Gene.Symbol, 
                          "+%28pp%29+", gene_alteration_frequency_5_cancers$Cancer, "=",  
                          as.numeric(sub("%","", 
                                         gene_alteration_frequency_Lung$Percent.Samples.Altered))/100  
                            )

tail(gene_cancer_freq_5_cancers)
```

Cancatenate the *gene_cancer_freq_5_cancers* with *correlated_genes.EA* objects of Edge Attributions.

```{r}
correlation_cancer.EA <- c(correlated_genes.EA, gene_cancer_freq_5_cancers)

write.table(correlation_cancer.EA, file = "data/cytoscape_input/new_version/Correlation+Cancer.EA",
            row.names = FALSE, quote = FALSE, col.names="Correlation+Cancer (class=java.lang.Double)")
tail(correlation_cancer.EA)
```




















```{r, attr.source='.numberLines'}
library(visNetwork)
nodes <- data.frame(id = 1:10,
                    label = paste("Node", 1:10),
                    value = c(10,5,3,7,2,3,2.6,2,9,2),
                    shape ="circle",
                    group= c("Gr1","Gr3"),
                    color= c("#DF0101", "blue")
)

edges <- data.frame(from = c(1,5,3,7,2,9,10,8,3,3,6),
                    to = c(5,3,5,1,5,1,2,3,7,4,9) )



graphe <- visNetwork::visNetwork(nodes, edges, width = "100%")

visNetwork::visOptions(graph= graphe, manipulation = TRUE,
                       selectedBy = "group",
                       highlightNearest = TRUE )

```

<!-- # Blocks -->

<!-- ## Equations -->

<!-- Here is an equation. -->

<!-- \begin{equation}  -->

<!--   f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k} -->

<!--   (\#eq:binom) -->

<!-- \end{equation}  -->

<!-- You may refer to using `\@ref(eq:binom)`, like see Equation @ref(eq:binom). -->

<!-- ## Theorems and proofs -->

<!-- Labeled theorems can be referenced in text using `\@ref(thm:tri)`, for example, check out this smart theorem @ref(thm:tri). -->

<!-- ::: {.theorem #tri} -->

<!-- For a right triangle, if $c$ denotes the *length* of the hypotenuse -->

<!-- and $a$ and $b$ denote the lengths of the **other** two sides, we have -->

<!-- $$a^2 + b^2 = c^2$$ -->

<!-- ::: -->

<!-- Read more here <https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html>. -->

<!-- ## Callout blocks -->

<!-- The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html -->
